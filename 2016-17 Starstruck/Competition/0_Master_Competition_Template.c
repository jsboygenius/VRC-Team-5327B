#pragma config(Sensor, in1,    RLine,          sensorLineFollower)
#pragma config(Sensor, in2,    LLine,          sensorLineFollower)
#pragma config(Sensor, in3,    LaunchPotL,     sensorPotentiometer)
#pragma config(Sensor, in4,    LaunchPotR,     sensorPotentiometer)
#pragma config(Sensor, in5,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  LauncherREnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  LauncherLEnc,   sensorQuadEncoder)
#pragma config(Sensor, dgtl11, DirectionLED,   sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, Lock,           sensorDigitalOut)
#pragma config(Motor,  port2,           RFBase,        tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           LFBase,        tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port4,           LaunchL1,      tmotorVex393_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port5,           LaunchR2,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RBBase,        tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port7,           LBBase,        tmotorVex393_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port8,           LaunchR3,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LaunchL23,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          LaunchR1,      tmotorVex393_HBridge, openLoop, reversed, encoderPort, dgtl1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
BUILD DATE: 7/19/16
AUTHOR: JAIVEER SINGH
V0.0.2
*/

//VRC Specific pragmas below
#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.h"
//VRC Specific pragmas above

//The following lines define each of the buttons and joysticks on the controller in more readable terms
#define X_Joy vexRT[Ch4]
#define Y_Joy vexRT[Ch3]
#define rot_Joy -vexRT[Ch1]
#define directionToggleBtn vexRT[Btn7U]
#define toggleSlowBtn vexRT[Btn7R]

#define LaunchUpBtn vexRT[Btn6U]
#define LaunchDwBtn vexRT[Btn6D]
#define LaunchUnlockBtn vexRT[Btn5U]
#define LaunchLockBtn vexRT[Btn5D]

#define LaunchTrigger vexRT[Btn7L]
#define Modifier1Star vexRT[Btn8U]
#define Modifier2Star vexRT[Btn8R]
#define Modifier3Star vexRT[Btn8D]

#define liftEngage vexRt[Btn8L]

#define overrideBtn vexRT[Btn7D]

//These global variables are used to manage toggle and emergency stop functions
int robotDirection = 1;

//Include statements to reference the other header files containing specific parts of the code
#include "Libraries/SmartMotorLib.h"
#include "4_CONSTANTS.h" //All constants used in the entire program

#include "1_Driver_Control.h" //Driver Control-specific functions
#include "2_Autonomous.h"

void resetGyro()
{

	SensorType[Gyro] = sensorNone; //Reset gyroscope at beginning of program
	SensorType[Gyro] = sensorGyro;
	wait1Msec(250);
}


//Predefined construct
void pre_auton()
{
	SmartMotorsInit();
	SmartMotorLinkMotors(LaunchL1, LaunchL23);
	SmartMotorLinkMotors(LaunchR1, LaunchR2);
	SmartMotorLinkMotors(LaunchR1, LaunchR3);
	SmartMotorsSetEncoderGearing(LaunchL1, 0.14);
	SmartMotorsSetEncoderGearing(LaunchR1, 0.14);
	SmartMotorRun();
	bStopTasksBetweenModes = false;
	resetGyro();
}

//Task controlling behavior during Autonomous period
task usercontrol()
{/*
	wait1Msec(2000);
	LaunchM(127);
	wait1Msec(750);
	LaunchM(30);
	wait1Msec(1000);
	LaunchM(-10);
	wait1Msec(500);
	LaunchM(0);
	*/
	startTask(Launch);
	startTask(Drive);
	startTask(EmergencyOverride);
	while(true) //Keep this task going so that the Vex Competition system does not mistake the robot for disconnected
	{
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDNumber(0, 0, SensorValue[LauncherLEnc]);
		displayLCDNumber(1, 0, SensorValue[LauncherLEnc]);
		EndTimeSlice();
	}
}

//Task controlling behavior during Driver Control period
task autonomous()
{
	ABase(0, 127, 0, 500);
	ABase(0, -127, 0, 500);
	LaunchM(127);
	ABase(0, 127, 0, 750);
	wait1Msec(1500);
	LaunchM(30);
	wait1Msec(500);
	ABase(-65, 0, 0, 1750);
	ABase(65, 0, 0, 500);
	for(int i = 0; i < 4; i++)
	{
		ABase(0, 65, 0, 600);
		wait1Msec(1500);
		ABase(0, -65, 0, 600);
		wait1Msec(500);
		ABase(65, 0, 0, 500);
		wait1Msec(500);
	}
}
